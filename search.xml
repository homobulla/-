<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端生成图片并压缩下载]]></title>
    <url>%2F2019%2F05%2F08%2F%E5%89%8D%E7%AB%AF%E7%94%9F%E6%88%90%E5%A4%9A%E5%BC%A0%E5%9B%BE%E7%89%87%E5%B9%B6%E7%BB%9F%E4%B8%80%E5%8E%8B%E7%BC%A9%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[今天遇到一个需求是要实现二维码的批量下载功能，输出一个zip包。 首先从图片角度而言并不是单纯的一张二维码即可，还附加一些名称和描述。思路有两种： 利用canvas直接绘制，将二维码绘制后再绘制配套文字等内容； 利用html2canvas实现截取DOM功能； 本质上来说两者是一样的,html2canvas也是利用了canvas绘制。因为对canvas不熟悉，于是采用了第二种方法。 引入和使用 html2canvashtml2canvas的使用很简单，一步到位： 1234import html2canvas from "html2canvas";html2canvas(document.querySelector("#capture")).then(canvas =&gt; &#123; imgData = canvas.toDataURL(); &#125;); 其中HTMLCanvasElement.toDataURL()返回base64,单个图片的下载： 1234567891011imgData = imgData.replace(_fixType(type), "image/octetstream");var saveFile = function(data, filename) &#123; var save_link = document.createElementNS("http://www.w3.org/1999/xhtml", "a"); save_link.href = data; // a标签href save_link.download = filename; //文件名 var event = document.createEvent("MouseEvents"); //创建事件，后边必须跟init初始化 event.initMouseEvent("click", true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null); save_link.dispatchEvent(event); // 派发前面初始化的点击事件，模拟用户点击&#125;;var filename = `$&#123;i.name&#125;-$&#123;i.keycode&#125;.$&#123;type&#125;`;saveFile(imgData, filename); // 单个下载 关于initEvent以及document.creatEvent,在这里能看到更多的信息以及Event.initEvent用new Event来代替。 下载功能是动态的创建一个a标签来实现的。若要实现多张图片下载并生成zip包，则用到了jsZip插件。 jsZip引入与使用1234567891011import JSZip from 'jszip';var zip = new JSZip();var img = zip.folder("images"); // 创建images文件夹用于存放图片img.file(filename, imgData, &#123; base64: true &#125;); // zip打包下载if (index == _devList.length - 1) &#123; // 判断循环结束，则开始下载压缩 zip.generateAsync(&#123; type: "blob" &#125;).then(function(content) &#123; saveAs(content, _devList[0].name + +new Date() +".zip"); &#125;); &#125; 这里需要注意一点是,需要下载file-saver模块，saveAs是其下的方法。 而JSZip模块中的base64.js会对文件格式进行检测，所以我们需要将之前canvas.toDataURL()得到的data去除前缀imgData = imgData.split(&quot;base64,&quot;)[1];。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端数据请求方案]]></title>
    <url>%2F2019%2F03%2F07%2F%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[趁着这段时间找工作正好总结一下之前在公司的多个项目。 首先是前端数据请求方面。数据请求是开发中非常重要的一部分，它涉及到与后端的交互，且很容易写出重复的代码，需要对其有一个统一的管理。 抽离与分层从项目整体出发，我们要做的第一步是抽离与分层。抽离代码能让我们在后期维护更加方便，同时也减少了重复代码。分层有助于我们将业务层和逻辑层隔离开，在版本迭代时会发挥巨大的作用。 考虑这样一个问题：假如后端获取用户信息的API名称改掉了，而这个API又在多个页面被调用（在壹诺微信端有四个入口，没有登录拦截），此时的维护成本很高。在这种情况下，我们可以将整个的数据请求从我们的View层拿出来，即在请求和页面之前加一层service层: 1234// get user infoexport async function getUserInfo(params, options) &#123; return post('/user/info', params);&#125; 在View里： 1234import &#123; getUserInfo &#125; from 'services.js';getUserInfo().then((data) =&gt; &#123; //这里对用户数据处理&#125;); 我们可以看到，通过架设一层服务层，页面和请求就完全隔离开了，无论是对后期迭代还是逻辑而言都是很好的方案。 拦截与控制当我们将页面和请求隔离开后，需要进一步考虑服务层，即所谓的请求。公司的后端接口都是统一要走网关的（防CSRF)，前端在请求接口时必须在header加上Authorization凭证。 难不成要在所有的接口请求都配置一变吗？ 这个时候就会想到将这部分相同的代码抽离出来，也就是对请求方法做一个封装： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//借款项目的封装const Axios = function(defaultConfig) &#123; return this.packageAxios(defaultConfig)&#125;Axios.prototype = &#123; packageAxios: function(options) &#123; this.getBaseParams(options) return Eajax(&#123;method: this.method, url: this.url, data: this.data, withCredentials: true, timeout: 10000&#125;) .then((res) =&gt; &#123; // 请求完成关闭loading if (this.UIComponents.loading) &#123; Indicator.close() &#125; // 未登录跳转登录页 if (res.data.errCode == -1 &amp;&amp; this.urlType === 1) &#123; localStorage.removeItem('token') apiCloud.exitLogin(&#123;&#125;) window.history.go(0) &#125; return res &#125;) .catch((error) =&gt; &#123; if (this.UIComponents.loading) &#123; Indicator.close() error.message.indexOf('timeout') !== -1 ? Toast(&#123; message: '请求超时', duration: 2000 &#125;) : '' &#125; &#125;) &#125;, getBaseParams: function(options) &#123; options = options || &#123;&#125; this.method = options.method || 'post' // 方法 this.url = options.url || process.env.BASE_URL + 'h5Interface' // 地址 this.urlParams = options.urlParams || '' // 地址参数 this.urlType = options.urlType || 0 // 判断url的类型来请求不同的接口 this.callback = options.callback || undefined // 回调 this.UIComponents = options.UIComponents || &#123;&#125; // 加载UI组件 if (this.UIComponents.loading) &#123; Indicator.open('加载中...') &#125; this.cutRequestData(options) // this.judgeEncrypt(options) &#125;, // 切换请求头格式 cutRequestData(options) &#123; switch (this.urlType) &#123; case 0: this.data = qs.stringify(&#123; requestMsg: JSON.stringify(&#123; header: &#123; transcode: options.data.transcode &#125;, body: options.data.body &#125;) &#125;) break case 1: this.data = options.data this.url = process.env.P2P_BASE_URL + this.urlParams break &#125; &#125; &#125;const createInstance = (defaultConfig) =&gt; &#123; return new Axios(defaultConfig)&#125;export default createInstance 上面代码是借款项目的请求封装，当时接口域名有四五个，每个域名的后端写法都不同。针对具体的业务做出不同的封装，不同的字段走不同的url甚至是不同的逻辑层。一个请求涉及到了参数配置、异常处理、接口拦截等方面，在这种情况下我们可以借用axios的拦截器来做文章。 12345678910// 请求之前的拦截器axios.interceptors.request.use(config =&gt; &#123; let url = config.url.includes('gw.inuol.com') &amp;&amp; !config.url.includes('sys/item') if (store.state.Authorization &amp;&amp; url) &#123; config.headers.Authorization = store.state.Authorization &#125; return config&#125;) 回到我们一开始说的Authorization里，我们可以在axios的请求拦截器里进行统一的配置。而对接口返回的异常处理也可以在响应拦截器里操作： 1234567891011121314151617181920212223242526272829303132333435axios.interceptors.response.use( function(response) &#123; return response &#125;, function(error) &#123; // // 服务器返回不是 2 开头的情况，会进入这个回调 // 可以根据后端返回的状态码进行不同的操作 const responseCode = error.response.status switch (responseCode) &#123; // 401：未登录 case 401: // 跳转登录页 Toast('登录失效，请重新登录') router.replace(&#123; path: '/login' &#125;) break // 404请求不存在 case 404: Toast('网络请求不存在') break case 500: Toast('服务器报错') break case 502: Toast('服务器报错') break // 其他错误，直接抛出错误提示 default: Toast('请求失败') &#125; return Promise.reject(error) &#125;) 所谓的拦截器其实就是一个链式调用，明白这点后即使不用axios,我们也可以仿照其拦截器原理自己封装一个请求的拦截器模式。当然最后还有一点是对于超时的处理，假如我们接口请求的那一刻服务器恰好出问题，在5s之后服务器恢复正常，但我们前端只能手动再次触法请求才能得知。有没有一种方法能做到连续请求呢？ 同样是在拦截器里可以做文章： 1234567891011121314151617181920212223242526272829303132axios.defaults.retry = 4;axios.defaults.retryDelay = 1000;axios.interceptors.response.use(undefined, function axiosRetryInterceptor(err) &#123; var config = err.config; // If config does not exist or the retry option is not set, reject if(!config || !config.retry) return Promise.reject(err); // Set the variable for keeping track of the retry count config.__retryCount = config.__retryCount || 0; // Check if we've maxed out the total number of retries if(config.__retryCount &gt;= config.retry) &#123; // Reject with the error return Promise.reject(err); &#125; // Increase the retry count config.__retryCount += 1; // Create new promise to handle exponential backoff var backoff = new Promise(function(resolve) &#123; setTimeout(function() &#123; resolve(); &#125;, config.retryDelay || 1); &#125;); // Return the promise in which recalls axios to retry the request return backoff.then(function() &#123; return axios(config); &#125;);&#125;); 上面展示的一个请求超时后继续发送请求3次后才会抛出错误，这样的话对接口暂时故障的容错率大大提高。 最后，程序设计无处不在，我们必须对代码的合理性和维护性有一定的把握，当然借款项目的请求封装还有一定的问题，以及拦截器的整合等等。这些路由、请求方法、服务层的分层也需要考虑清楚。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iframe的使用]]></title>
    <url>%2F2019%2F02%2F22%2Fiframe%2F</url>
    <content type="text"><![CDATA[关于iframe最常听到的是“安全性问题”、“性能问题”，而我在之前也很少使用iframe,虽说其功能很强大。 使用的契机是源于一个微信端的项目。其中有两个报表页面不仅后端返回数据复杂嵌套很深，而且页面内容更是臃肿。而这两个报表同样会在公司app里使用。于是便将两个报表单独抽离出去作为单个页面。 app引用h5页面很简单，一个webView即可。而在微信端的话，我只想到了使用iframe来嵌套报表。 而在代码层面，遇到最大的问题是兼容性问题。也就是在安卓设备整个iframe覆盖整个屏幕高度了，但在苹果设备则显示不全。 1234567891011121314151617 &lt;iframe id="daiqian" :src="iframeUrl" frameborder="0" :scrolling="scroll" style="width:100vw!important;height:auto!important;" &gt;&lt;/iframe&gt;#iframe &#123; overflow: scroll; -webkit-overflow-scrolling: touch; min-width: 100%; width: 100%; width: 1px; -webkit-overflow-scrolling: touch; overflow: auto;&#125; 首先在created期间判断设备类型： 123let u = navigator.userAgent; this.isAndroid = u.indexOf("Android") &gt; -1 || u.indexOf("Adr") &gt; -1; //android终端 this.isiOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端 然后在mounted里获取iframe元素进行样式调整： 12345678910111213141516171819202122232425262728293031323334let _this = this; let daiqian = document.querySelector("#daiqian"); var w = document.documentElement.clientWidth || document.body.clientWidth; var h = document.documentElement.clientHeight || document.body.clientHeight; console.log(h); if (_this.isiOS) &#123; this.scroll = "no"; // 如果是苹果设备，则属性scrolling = 'no' &#125; // 监控iframe 加载事件，这里是为了防止iframe还未加载完成就对iframe父级页面进行操作。 if (daiqian.attachEvent) &#123; // 兼容IE9以下 daiqian.attachEvent("onload", function() &#123; if (this.isAndroid) &#123; daiqian.style.height = `$&#123;h&#125;px`; // 安卓设备必须显示声明具体屏幕高度。 &#125; setTimeout(() =&gt; &#123; _this.$Indicator.close(); &#125;, 1500); &#125;); &#125; else &#123; daiqian.onload = function() &#123; if (_this.isAndroid) &#123; daiqian.style.height = `$&#123;h&#125;px`; // 安卓设备必须显示声明具体屏幕高度。 &#125; setTimeout(() =&gt; &#123; _this.$Indicator.close(); &#125;, 1500); &#125;; &#125; 总的来说iframe很强大，但对其的了解只限于知识点的片面了解。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex丢失问题]]></title>
    <url>%2F2019%2F02%2F19%2Fvuex%E7%9A%84%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在使用vuex时遇到的一个问题是一旦页面刷新，存在vuex的数据全部丢失。即刷新页面以前的内存就被释放了，脚本重新加载，变量重新赋值。 如何解决这个问题？ 目前已经有很好的第三方插件帮我们做到vuex持久化，譬如vuex-persistedstate 当然我在项目中并没有采取第三方插件，而是采用了localStorage这个方案。 首先我在app.vue里监听页面刷新： 1234567 //在页面刷新时将vuex里的信息保存到localStorage里window.addEventListener("beforeunload", () =&gt; &#123; localStorage.setItem(VERSION,JSON.stringify(this.$store.state)); &#125;);window.addEventListener("pagehide", () =&gt; &#123; localStorage.setItem(VERSION,JSON.stringify(this.$store.state));&#125;); 页面一旦刷新则将vuex的state存入本地，然后在main.js中： 123456789101112131415161718192021222324252627282930313233// 登录拦截，无法依据后端判断// 版本号 ，是否需要用户重新登录// 需要则修改版本号global.VERSION = 'version4'// local和store的混合const reSet = (store, local) =&gt; &#123; for (let i in store) &#123; store[i] = store[i] ? store[i] : local[i] &#125; return store&#125;router.beforeEach((to, from, next) =&gt; &#123; // 在页面加载时读取localStorage里的状态信息; let local = JSON.parse(localStorage.getItem(VERSION)) if (localStorage.getItem(VERSION)) &#123; store.replaceState(reSet(store.state, local)) &#125; else &#123; localStorage.clear() store.commit('RESETSTATE') &#125; store.state.uid || to.path === '/' || to.path === '/login' || to.path == '/regist' || to.path === '/forgetPass' || to.path === '/loanDetails' || to.path === '/lendingDetails' || to.path === '/creditInfo' ? next() : router.push('/login')&#125;) 在这里进入路由之前要先将localStorage的数据传递给vuex，但这里有个问题是localStorage内的数据并不是完全和vuex的数据是同步的。即我在页面A刷新后的状态会与我在其他页面的状态修改造成冲突。 于是我定义了一个reSet还混杂vuex和localStorage的数据，以有数据的为标准来集合。 当然这样做的话，每一次的路由跳转都要进行这一步。以后会尝试其他的方案。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018]]></title>
    <url>%2F2018%2F12%2F05%2F2018%2F</url>
    <content type="text"><![CDATA[2018就要过去了，我很怀念它。不变的年终总结，不变的开头语。每年只有这个时候我才能清晰的把握住时间的流逝。2018这一年总的来说并没有达到我的目标（假如我有既定目标的话），其中酸甜苦辣百态滋味，很多情绪化的东西、感情上的悸动在当下难以用文字准确地描述，我能记录和总结的，大概只是大风吹过后的一片狼藉，那些很难忘却的被我印刻在脑子里的东西。尽量用上帝视角来书写，而不是任由我自己的情绪发泄。 我很难无愧于心，在‘有思想的猪“和”行动的人“之间徘徊，倘若痛苦和遗憾能用算数来运算，那我大概有两倍的遗憾吧。 这篇文章的话我不会再搞什么Flag了，只是作为日后回看此刻心情的凭证。 自我和欲望这一年最大的改变是放弃了倾诉，个人的情感诉求只能寻求自我来达到解脱，不再去找别人说一些触底的话。这两天微博上的一个话题是#人成熟的标志之一的失去了倾诉欲#，倾诉欲其实一直都在，只是我们逐渐接受了没有合适的倾诉对象的这个事实。这是一种孤独感。 以前我用什么办法来抗拒这种孤独感呢？ 一直以来我都是通过网络途径，无人知我是人是狗。网友是充当了一个回收站的角色，我可以不加修饰毫无遮盖的袒露最内心的声音，就像在对着茫茫宇宙或深山丛林呐喊，我永远不担心也不在意对方给予我的反馈，这样的一种社交场景让我感觉到巨大的安全感，因为我不用在意自己在对方心里的印象，也不需要担心负能量的传递或者价值观的碰撞。情感的宣泄一旦产生，它的流向便不受控制。日积月累下网络世界成了我躲藏的角落，进而影响到我自己的现实生活。比如隐约抗拒交际，某段关系一旦摩擦就让我难受，要么更近要么远离。这种鸵鸟式的处理方式实在是弱爆了。 在那样一种情形下，我养成了一个坏的交友习惯。即一旦对方进入我的内心，我便毫不犹豫几乎没有隐瞒的吐露了自己的所有想法。，想来大概是因为我内心深处很渴望有谈心的朋友吧。当然这种发自肺腑的精神需求被我的性格压制的死死的。 可没有什么人能百分百理解另一个人，我们能遇到在某件事或某个观点相近的人就已经足够幸运了。本质上大多数的交往都是嬉笑怒骂而尽量减少想法和观点的冲突。 再加上这一年来，对于一些东西我更加容易放弃了。大约是别人的努力在我这里就是强求。所以说人际关系的问题在这一年里还是没离开我。我是真的太感动了。 关于欲望，这一年能明显的感觉到自己有些随遇而安得过且过的味道，外部环境无论是工作还是生活都很安稳，安稳地让我习惯了目前的生活状态。于是乎欲望就被仍一边。 坦白说我偶尔也会焦虑未来或者如何金钱。但这种对钱的渴望一点都不够强烈，类似于照镜子看到自己的脸，然后幻想一下吴彦祖就放过自己了，打心底觉得差不多也就这样了不会再有什么变化。这种心理就是我这一年对钱的态度。 爱情和工作在跨年的那刻我依旧是单身。今年喜欢过一个女孩，但因为我这人不会谈恋爱且不是对方的菜，然后就没有然后了。我和她就像刺猬一样，不用心不靠近其乐融融，一旦靠近就互相都受伤。一段关系最起码的是双方不会感到疲惫。很遗憾我和她都没达到这个要求。 我其实还蛮在意别人怎么对我的，我对别人的态度大都是基于别人对我的态度上的。关于爱情还是学不会。（此处应该有一剪梅) 未完待续的…]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非职业规划的胡扯]]></title>
    <url>%2F2018%2F11%2F12%2F%E4%B8%8B%E4%B8%80%E9%98%B6%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[不晓得能不能算是一个成熟的职业规划。 看了下日历，离春节还剩下88天，不到三个月的时间。我甚至还没决定去哪个城市发展。（笑 最近询问了一些从北京深圳回来的人，‘租房’，‘地铁’，‘加班’这些出现频率极高的字眼都意味着“工作艰难”。从现实角度而言，我大概是倾向于北京的，离家近而且吃东西也好气候也好更加符合我北方人的标准，但租房这事让我很担忧，而且雾霾之都名声在外。深圳的话，靠近海的地方总有种吸引力。 当然这些都是次要的。因为不管深圳还是北京，我大约是很难最终定居下来，高额的房价望而却步。在我心中也大致是一个中转站的存在吧，很多人说生活节凑快，我倒是真想体会一番。毕竟我这人太过懒惰鼠目寸光。短期利益一直打不过看不到的长期利益。需要某种外部环境来刺激我。 回顾毕业到现在的日子，在职业规划这方面基本是处于被生活推着走的角色。当初如果不是因为那次面试，我怎么会坐在这里敲代码。当时的我也并不会预想到这些吧。比较有趣的一点是，不管我多么厌恶我自己，可总有一种莫名的自信支撑着我，让我认为自己以后一定会混的很好。 直到今天，我才隐约明白那种情绪究竟是什么？ 一种无路可退的最终依靠。 换句话说，当时是只要迈开步子走就是前进。所以阴差阳错的成了一个程序员。其实我一直把写程序当作工具，想用这个工具去做其他的工作，也没想过真的一脚踏进这个圈子整天坐在电脑前敲代码。 这个话题暂且不表，今天是要考虑职业规划的问题,即年后的问题。这段时间如何准备？如何选择城市？该搞一个什么样的学习路线？这些问题才是亟需解决的。 首先一个重点是react-native,当然react也同样需要。至少将music项目造出来，初步引入redux，做些笔记达到当初对vue的了解。 其次是对js宿主环境即浏览器的学习，控制台调试、浏览器的工作、网络请求、缓存、认证等问题的认知。 而后是对js本身的研究，把高三看一遍至少。对一些高级函数高级特性深入了解，语言特性的熟练掌握。 最后的话，是对后端的学习。将之前的玩具koa用起来搭建一个接口服务。 上面的一些问题都必须用文字用计划表达出来展现在纸上。空想主义误国，尤其是我这种拖延症晚期的人。 ok，第二阶段需要探讨一下长时间的规划。毕业一年的发展要我自己来评价的话，前期的发展是十分巨大的，在迅速的吸取各种各样的知识。但自今年四月开始就没有太多的感觉了。很明显我进入了舒适区，无论是工作环境还是学习的内容很难让我有压迫感。 我知道我需要换一个地方了。 我想定个两年目标，其他方面的先不说，在程序员这条路上，希望两年后的我技术能达到进任何一个大厂。 还剩下一年时间]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象编程（一）]]></title>
    <url>%2F2018%2F10%2F26%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B1%2F</url>
    <content type="text"><![CDATA[oop作为一种编程范式，它将真实世界各种复杂的关系抽象为一个个对象，然后由对象之间的分工与合作来完成对真实世界的模拟。 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。 面向对象有三大特性： 封装、继承、多态 在js中，es5是通过模拟class概念来实现的。类的本质是保存一个函数的变量，该函数有自己的属性property和方法method。 生成对象new第一步是如何生成一个对象，在javascript里，对象不是基于class的（es5)，而是基于构造函数（constructor）和原型链（propertype）。 一个基本的生成对象过程如下： 123456789function Person() &#123; this.attributes = 'homoSapiens' this.say = function() &#123; console.log(this.attributes) &#125;&#125;let F = new Person()F.say() 我们用一个首字母大写的函数名来区分于普通函数，attributes是Person类的属性，say则是其方法。其中new做了下面几件事： 创建一个空对象，作为将要返回的对象实例。 将这个空对象的原型，指向构造函数的prototype属性。 将这个空对象赋值给函数内部的this关键字。 开始执行构造函数内部的代码。 this总是指向当前对象，通过构造函数添加属性和方法也就是通过this添加的方法和属性。当我们实例化一个新的对象时，this指向的方法和属性会重新在内存中创建。于是我们可以使用原型链来让每个实例的属性和方法指向同一个地址（当一些属性和方法不需要修改时）。 1234567function Person(name)&#123; this.name = name&#125;Person.prototype.attributes = 'homoSapiens'Person.prototype.say = function() &#123; console.log(this.attributes)&#125; 这样做的好处是减少了实例化对象的内存开销，但当修改某个对象的属性和方法时会影响到由同一个构造器生成的其他对象。 在es6中，class是构造函数的语法糖，上面代码改写之后： 1234567891011class Person&#123; constructor(name)&#123; this.name = name this.attributes = 'homoSapiens' &#125; say()&#123; console.log(this.attributes) &#125;&#125;typeof Person // 'function'Person === Person.prototype.constructor // true class本质上是构造函数的变形。类本身指向构造函数。同时类的所有方法都定义在类的prototype属性上。 原型与原型链js中所有的对象由构造函数而来，也都继承构造函数的原型对象中的方法和属性。 在对象内部我们通过以下两种方式访问其继承的原型： obj.constructor.prototype obj._proto_(浏览器暴露的，非es`方法) js中所有对象都来自于构造函数，即继承某个原型，而原型本身也会继承其他的原型，最后形成一条原型链。原型链的工作机制与作用域的类似。 所有的原型链最终都指向Object.prototype。Object.prototype本身也是对象，Object.prototype.__proto__是什么呢？ 答案是null，大概是为了中止原型链吧。同样也解释通了 1typeof null === 'object' Object.create1Object.create(null) // 唯一不会继承任何原型方法的对象创建]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[generator和async]]></title>
    <url>%2F2018%2F10%2F24%2Fgenerator%2F</url>
    <content type="text"><![CDATA[异步中的generator和async generator内部多种状态。执行generator函数会返回一个遍历器。不仅是状态机，还是遍历器生成函数，我们可以遍历每一个状态。于是又称之为生成器。 async函数的实现原理，就是将generator函数和自动执行器，包装在一个函数里。 如何理解这句话，内部代码如何实现？是这篇文章的重点。 遍历器的next首先，generator函数会返回一个指向内部状态的指针对象，我们必须调用遍历器的next方法才能走到generator函数内部的下一个状态。 于是，我们需要看一下next方法： 123456789101112const Iterator = arr =&gt; &#123; let nextIndex = 0 return &#123; next: function() &#123; return nextIndex &lt; arr.length ? &#123; value: arr[nextIndex++] &#125; : &#123; done: true &#125; &#125; &#125;&#125;const demo = Iterator([1, 2, 3])demo.next() yield 与 *回到generator本身，前面已经讲generator函数的调用并不会执行，而是必须用遍历器对象的next方法。即每次调用next,内部指针就从接着从上次停下的地方继续执行，直到遇到yield语句。 即generator本身生成了遍历器，所以它的执行是分阶段用next不断触发的。yield表达式是暂停执行标记，next则是继续执行。 我们可以在generator函数内很容易控制语句的执行与暂停，每一次的yield表达式都会返回相应的value,基于此我们可以将异步执行放在yield中，暂停指针，当返回value即有结果时，将value抛出再用next继续下一步。 123456789function* Ge()&#123; yield 'homo'; yield 'bulla'; return 'very Handsome'&#125;let myself = Ge();myself.next() // homomyself.next() // bullamyself.next() // very Handsome 上面的Ge函数通过调用next三次结束。返回一个{value: &quot;very Handsome&quot;, done: true}，包含value和done属性的对象。value代表当前指针，done则表示遍历是否结束。 需要注意的是，yield是一个惰性求值语句，只有调用next时，才会执行其后面的语句。 yield表达式本身没有返回值undefined,next方法可以带一个参数，该参数就被当作上一个yield的返回值。这给我们提供了控制generator函数内部执行的一个接口。 也就是说，generator函数从暂停状态到恢复运行。它的上下文状态是不变的。 async接下来是async,首先它和Generator是不同的。async会返回一个promise对象，在一些复杂的异步场景，promise的all和race会得心应手。而Generator只是一个生成器。 我们来看一下Generator和async的使用： 1234567891011121314151617// 使用 generatorvar fetch = require('node-fetch');var co = require('co');function* gen() &#123; var r1 = yield fetch('https://api.github.com/users/github'); var json1 = yield r1.json(); console.log(json1.bio);&#125;co(gen);// 使用 asyncvar fetch = require('node-fetch');var fetchData = async function () &#123; var r1 = await fetch('https://api.github.com/users/github'); var json1 = await r1.json(); console.log(json1.bio);&#125;;fetchData(); async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await,并内置执行器。 进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue之响应系统]]></title>
    <url>%2F2018%2F10%2F17%2Fvue%E4%B9%8B%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[vue之响应系统在vue中，我们使用$watch来观察某个对象，当被观察者发生变化时执行指定的观察者。比如最基本的当被观察者是一个简单字段： 123456789const ins = new Vue(&#123; data: &#123; a: 1 &#125;&#125;)ins.$watch('a', () =&gt; &#123; console.log('修改了 a')&#125;) 当字段a修改之后，会触发$watch的回调函数。在vue中，会考虑更多的内容，比如如何深度观测，如何处理数组以及其他的边界条件，比如我们也会写成下面这种形式： 123456789watch: &#123; ruleForm: &#123; handler() &#123; conole.log('修改了ruleForm！') &#125;, deep: true // 深度监听，被观察者是一个对象。 &#125; &#125;, 摆在我们面前的第一个问题是，如何得知被观察者发生变化了？答案是Object.defineProperty（在接下来vue3版本，会通过proxy来实现），通过该函数为对象的每个属性设置一对getter/setter从而得到被改变的属性： 12345678Object.defineProperty(data,'a',&#123; set()&#123; console.log('设置了a') &#125;, get()&#123; console.log('读取了a') &#125;&#125;) 此时就实现了第一步，对属性a的设置和获取操作的拦截。 第二步，在获取属性a的时候收集依赖，然后在设置属性a的时候触发依赖集合。考虑几个问题： 只能访问某个具体定义属性： for循环包裹 get函数需返回值 data为一个嵌套对象时： 递归定义 如下： 123456789101112131415161718192021222324252627282930313233343536373839const data = &#123; a: 1, b: 1&#125;// for循环将访问器属性包裹for (let key in data) &#123; const dep = [] let val = data[key] // 缓存字段原有的值 Object.defineProperty(data, key, &#123; set (newVal) &#123; // 如果值没有变什么都不做 if (newVal === val) return // 使用新值替换旧值 val = newVal dep.forEach(fn =&gt; fn()) &#125;, get () &#123; // target 此时已保存了依赖函数 dep.push(Target) return val // 将该值返回 &#125; &#125;)&#125;// Target 是全局变量let Target = nullfunction $watch (exp, fn) &#123; // 将 Target 的值设置为 fn Target = fn // 读取字段值，触发 get 函数 data[exp]&#125;data.a = 2data.b = 3$watch('a', () =&gt; &#123; console.log('第一个依赖')&#125;)$watch('b', () =&gt; &#123; console.log('第二个依赖')&#125;) 首先定义了全局变量Target，然后在$watch中将Target的值设置成fn，也就是依赖。接着读取字段的值data[exp]从而触发被设置的属性的get函数，而在get函数中，此时的Target变量就是我们要收集的依赖，将其push进dep数组。 还有第三个问题，当对象为一个嵌套复杂类型时，需要递归将其变成响应式属性： 1234567891011121314151617181920212223function walk (data) &#123; for(let key in data) &#123; const dep = [] let val = data[key] // 如果 val 是对象，递归调用 walk 函数将其转为访问器属性 const nativeString = Object.prototype.toString.call(val) if (nativeString === '[object Object]') &#123; walk(val) &#125; Object.defineProperty(data, key, &#123; set (newVal) &#123; if (newVal === val) return val = newVal dep.forEach(fn =&gt; fn()) &#125;, get () &#123; dep.push(Target) return val &#125; &#125;) &#125;&#125;walk(data) 同样需要修改$watch函数： 123456789101112131415const $watch = (exp,fn)=&gt;&#123; Target = fn let pathArr, obj = data // 是否嵌套 if (/\./.test(exp))&#123; pathArr = exp.split('.') // 依次循环探底动态修正obj pathArr.forEach(p =&gt;&#123; obj = obj[p] &#125;) return &#125; data[exp]&#125; $watch函数实质上就是为了访问到要观察的字段，触发该字段的get函数，进而收集依赖。 归纳来看，我们通过Object.defineProperty来劫持对象的set和get方法，用$watch来触发get方法以此来收集依赖。然后在设置属性时触发所有依赖。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洋葱模型]]></title>
    <url>%2F2018%2F10%2F16%2F%E6%B4%8B%E8%91%B1%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[洋葱模型koa2最大的特点是独特的中间件流程控制。在其源码中使用koa-compose: 1const compose = require('koa-compose'); 正是基于这个中间件，才能保证每个async/await返回的promise的执行顺序得到保证。 其核心思想是：当遇到await next()时，中断当前中间件的转而执行下一个中间件，当执行到最后一个中间件时，再倒序执行next()之后的代码。 下图很形象的展示了此过程，即洋葱模型。 首先koa的app.listen使用this.callback()来包裹node的httpServer的回调函数： 12345listen(...args) &#123; debug('listen'); const server = http.createServer(this.callback()); return server.listen(...args);&#125; 在this.callback()里,用comopse处理middleware这个中间件的集合： 123456789 callback() &#123; const fn = compose(this.middleware);// this.middleware是一个数组，所有的中间件都被push进去，在use函数会做这一步。 const handleRequest = (req, res) =&gt; &#123; const ctx = this.createContext(req, res); return this.handleRequest(ctx, fn); &#125;; return handleRequest; &#125; comopse这个方法在koa-compose源码： 1234567891011121314151617181920212223242526function compose (middleware) &#123; /** * @param &#123;Object&#125; context * @return &#123;Promise&#125; */ return function (context, next) &#123; // last called middleware # let index = -1 return dispatch(0) // dispatch函数遍历整个middleware数组 function dispatch (i) &#123; if (i &lt;= index) return Promise.reject(new Error('next() called multiple times')) index = i let fn = middleware[i] // 每一个中间件依次赋值执行 if (i === middleware.length) fn = next // 执行到最后一个中间件，则执行next(),逆序。 if (!fn) return Promise.resolve() try &#123; // 把dispatch(i+1)传给`middleware`中的方法 // 将context一路传给中间件 return Promise.resolve(fn(context, dispatch.bind(null, i + 1))); &#125; catch (err) &#123; return Promise.reject(err) &#125; &#125; &#125;&#125; compose函数接受中间件的集合(Array),返回一个promise,这个返回的promise带着context对象一直在中间件传递。 关于compose函数的分析，假设有三个m1 m2 m3三个函数： 1234567891011async function m1(next) &#123; console.log('m1') await next()&#125;async function m2(next) &#123; console.log('m2') await next()&#125;async function m3(next) &#123; console.log('m3')&#125; 我们希望构造一个函数来确保m1 m2 m3函数顺序执行。即执行m1完毕后，await next()调用m2,即我们需要将m2作为参数传给m1，即将middleware中的下一个中间件fn作为未来next的返回值: 12345678let next1 = async function() &#123; await m3()&#125;// 进一步 m2 执行完调用m3let next2 = async function() &#123; await m2(next1)&#125;m1(next2) 对于n个async来说，可以将产生nextn函数抽象为一个函数: 12345678910const createNext =(middleware,oldNext) =&gt;&#123; return async _=&gt;&#123; await middleware(oldNext) &#125;&#125;let next1 = createNext(m3,null);let next2 = createNext(m2,next1);let next3 = createNext(m1,next2);next3() 再次将middleware作为数组来精简： 1234567891011let middlewares = [m1,m2,m3];let len = middlewares.lenght;// 最后一个中间件的nextlet next = async function()&#123; return Promise.resolve()&#125;for(let i = len-1;i&gt;0;i--)&#123; next = createNext(middlewares[i],next)&#125;next()]]></content>
      <categories>
        <category>koa</category>
      </categories>
      <tags>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa初探]]></title>
    <url>%2F2018%2F10%2F15%2Fkoa%2F</url>
    <content type="text"><![CDATA[koa是一个轻健的 web 开发框架。一个基于koa写的post请求：12345678910111213141516const Koa = require('koa')const app = new Koa()const bodyParser = require('koa-bodyparser')app.use(bodyParser())app.use(async ctx =&gt; &#123; if (ctx.url === '/' &amp;&amp; ctx.method === 'POST') &#123; // 当POST请求的时候，中间件koa-bodyparser解析POST表单里的数据，并显示出来 let postData = ctx.request.body ctx.body = postData &#125; else &#123; ctx.body = `&lt;h1&gt;404&lt;/h1&gt;` &#125;&#125;)app.listen(3000, () =&gt; &#123; console.log('[demo] request post is starting at port 3000')&#125;) koa-bodyparser是一个middleware，Koa应用程序是一个包含一组中间件函数的对象，它是按照类似堆栈的方式组织和执行的。 koa的构成koa的源码由四部分组成： application.js context.js request.js response.js application.js为入口文件，context.js是上下文对象，request.js是请求相关，response.js是返回相关。 koa的执行分为两步： 初始化，这一阶段为初始化使用到的中间件并在指定端口侦听 app.use拿到一个回调函数，它将中间件推入一个叫 middleware 的 list 中。 12345678910111213use(fn) &#123; if (typeof fn !== 'function') throw new TypeError('middleware must be a function!'); // 中间件必须是一个函数 if (isGeneratorFunction(fn)) &#123; deprecate('Support for generators will be removed in v3. ' + 'See the documentation for examples of how to convert old middleware ' + 'https://github.com/koajs/koa/blob/master/docs/migration.md'); fn = convert(fn); &#125; debug('use %s', fn._name || fn.name || '-'); this.middleware.push(fn);// 将fn push return this; &#125; listen的时候执行函数。 1234567891011121314151617listen(...args) &#123; const server = http.createServer(this.callback()); // createServer语法糖，请求事件的监听函数为 this.callback() return server.listen(...args);&#125;callback() &#123; const fn = compose(this.middleware); // 将中间件函数合成一个函数fn // ... const handleRequest = (req, res) =&gt; &#123; const ctx = this.createContext(req, res); // 使用req和res创建一个上下文环境ctx return this.handleRequest(ctx, fn); &#125;; return handleRequest; &#125; 中间件的依次执行是如何实现的？conpose函数的实现=&gt;koa-compose是基于洋葱模型来实现。 简单来说就是，它从第一个中间件开始，遇到next就中止本中间件的代码转而执行下一个中间件的代码…一直到最后一个中间件，然后从最后一个中间件开始倒退执行next,类似于堆栈的先进后出。 请求处理阶段,请求到来，进行请求的处理 请求处理是在request.js当中的handleRequest函数： 12345678910111213handleRequest(ctx, fnMiddleware) &#123; const res = ctx.res; res.statusCode = 404; // koa默认的错误处理函数，它处理的是错误导致的异常结束 const onerror = err =&gt; ctx.onerror(err); // respond函数里面主要是一些收尾工作，例如判断http code为空如何输出，http method是head如何输出，body返回是流或json时如何输出 const handleResponse = () =&gt; respond(ctx); // 第三方函数，用于监听 http response 的结束事件，执行回调 // 如果response有错误，会执行ctx.onerror中的逻辑，设置response类型，状态码和错误信息等 onFinished(res, onerror); return fnMiddleware(ctx).then(handleResponse).catch(onerror); &#125; 其中ctx是一个上下文对象，request和response两个文件来扩展属性，并将其转为ctx对象。listen回调中通过createContext函数来创建ctx： 123456789101112131415createContext(req, res) &#123; const context = Object.create(this.context); //使用Object.create方法是为了继承this.context但在增加属性时不影响原对象 const request = context.request = Object.create(this.request); const response = context.response = Object.create(this.response); context.app = request.app = response.app = this; context.req = request.req = response.req = req; context.res = request.res = response.res = res; request.ctx = response.ctx = context; request.response = response; response.request = request; context.originalUrl = request.originalUrl = req.url; context.state = &#123;&#125;; return context; &#125; 请求到来时，首先执行第一个阶段封装的compose函数，然后进入handleResponse中进行一些收尾工作。至此，完成整个请求处理阶段。]]></content>
      <categories>
        <category>koa</category>
      </categories>
      <tags>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础一]]></title>
    <url>%2F2018%2F09%2F04%2Fpython1%2F</url>
    <content type="text"><![CDATA[重视语言特性，而不是语言 —王银 变量定义 算术运算 for 循环语句，while 循环语句 函数定义，函数调用 递归 静态类型系统 类型推导 lambda 函数 面向对象 垃圾回收 指针算术 goto 语句 number and stringnumber有 floast 和 int 类型除了 int 和 float，Python 还支持其它数字类型，例如 Decimal 和 Fraction。Python 还内建支持 复数 ，使用后缀 j 或 J 表示虚数部分（例如，3+5j）。 1234568 / 8# 1.0 / 永远返回一个float8 // 5 # 18 // 5 # 1.0 // 永远返回小数点之前的整数，至于是float 还是 int ，取决于除数和被除数的类型8 % 5 # 3 % 求摸操作符 ,返回类型同上# 整数和浮点数的混合计算中，整数会被转换为浮点数 string单双引号，字符转义\,如果你前面带有 \ 的字符被当作特殊字符，你可以使用 原始字符串，方法是在第一个引号前面加上一个 r: 12345&gt;&gt;&gt; print('C:\some\name') # here \n means newline!C:\someame&gt;&gt;&gt; print(r'C:\some\name') # note the r before the quoteC:\some\name python 提供了类似 html 的&lt;pre&gt;标签的功能，可以保留换行符和空格，一是使用三引号： &quot;&quot;&quot;...&quot;&quot;&quot; 或者 &#39;&#39;&#39;...&#39;&#39;&#39;,其中可以用 \ 来去除换行。 12345678910111213141516&gt;&gt;&gt; print ('''\demo this is line one happy this is line two sad''')demo this is line one happy this is line two sad&gt;&gt;&gt; print ('''demo this is line one happy this is line two sad''')demo this is line one happy this is line two sad&gt;&gt;&gt; 用+来链接字符和表达式，用*来重复字符串,字符同样可以被检索，（支持正负）以及切片， 1234&gt;&gt;&gt; homobulla[:1] + homobulla[1:]'homobulla'&gt;&gt;&gt; homobulla[:4] + homobulla[4:]'homobulla' 字符串不可变(js 中 string 同样不可变，但编译器不报错),内置函数 len() 返回字符串长度: 123456789&gt;&gt;&gt; word[0] = 'J' ...TypeError: 'str' object does not support item assignment&gt;&gt;&gt; word[2:] = 'py' ...TypeError: 'str' object does not support item assignment&gt;&gt;&gt; s = 'supercalifragilisticexpialidocious'&gt;&gt;&gt; len(s)34 list复合数据类型之一：列表，基本就是 js 的数组，切片，赋值，浅拷贝，嵌套等等。 range(int1,int2,int3)函数生成一个可迭代列表，list()也是一个迭代器 123&gt;&gt;&gt; list(range(0,101,10))[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100] python 中的控制流语句for 循环当在循环中进行列表的修改时，可以迭代其副本，即使用切割标识符： 123456&gt;&gt;&gt; for w in words[:]: # Loop over a slice copy of the entire list.... if len(w) &gt; 6:... words.insert(0, w)...&gt;&gt;&gt; words['defenestrate', 'cat', 'window', 'defenestrate'] if 语句if…elif…elif…else(非必需) break 和 continue 语句, 以及循环中的 else 子句break跳出当前循环，循环中可以套else语句用来循环那些条件为flase的情况，当有break的时候就不会执行了。 123456789101112131415161718&gt;&gt;&gt; for n in range(2, 10):... for x in range(2, n):... if n % x == 0:... print(n, 'equals', x, '*', n//x)... break... else: # 这里的else不是在上面的if里，而是在外层的for循环中，... # loop fell through without finding a factor... print(n, 'is a prime number')...2 is a prime number3 is a prime number4 equals 2 * 25 is a prime number6 equals 2 * 37 is a prime number8 equals 2 * 49 equals 3 * 3 pass 语句pass语句类似于占位语句，即语法上需要有语句但真正程序什么也不做。 函数 无论什么语言，函数都是重中之重. ——homobulla 函数的定义关键字def,在其后必须跟有函数名和包括形式参数的圆括号。函数体语句从下一行开始，必须是缩进的。函数体的第一行语句可以是可选的字符串文本，这个字符串是函数的文档字符串，或者称为 docstring。 1234567def fib(n): """Print a Fibonacci series up to n.""" a,b = 0,1 while(a&lt;n): print(a,end=' ' ) a,b = b,a+b print() 函数内变量、参数、作用域的问题：局部符号表:js 当中局部变量吧。函数调用会为函数局部变量生成一个新的符号表。变量引用首先在局部符号表中查找，然后是包含函数的局部符号表，再然后是全局符号表，最后是内置符号表，和 js 的原型链类似。全局变量不能在函数中直接赋值（除非用 global 语句命名），尽管他们可以被引用。参数的问题：函数的实参在函数调用时引入局部符号表。所以实参是传值调用(此处的值是一个对象引用，而不是该对象的值)return语句从函数中返回一个值，不带表达式的 return 返回 None。过程结束后也会返回 None。参数不能多次赋值，尤其是当参数为一个对象时，赋值操作会被累加。函数的调用更加的多样和弱检测，]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Component]]></title>
    <url>%2F2018%2F08%2F20%2Fweb-component%2F</url>
    <content type="text"><![CDATA[Web Compontent Web Compontent 是一套创建可重用的定制元素的技术,旨在为了 Web 组件模型统一化 由以下四种技术组成： Custom elements（自定义元素）：一组 JavaScript API，允许您定义 custom elements 及其行为，然后可以在您的用户界面中按照需要使用它们。 Shadow DOM（影子 DOM）：一组 JavaScript API，用于将封装的“影子”DOM 树附加到元素（与主文档 DOM 分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。 HTML templates（HTML 模板）： 和 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。 HTML Imports（HTML 导入）：一旦定义了自定义组件，最简单的重用它的方法就是使其定义细节保存在一个单独的文件中，然后使用导入机制将其导入到想要实际使用它的页面中。HTML 导入就是这样一种机制，尽管存在争议 — Mozilla 根本不同意这种方法，并打算在将来实现更合适的。 即模板插槽、影子节点、自定义元素、Imports。 实现web component的基本方法通常如下所示： 使用 ECMAScript 2015 类语法创建一个类，来指定 web 组件的功能. 使用 CustomElementRegistry.define()方法注册您的新自定义元素 ，并向其传递要定义的元素名称、指定元素功能的类以及可选的，其所继承自的元素。 如果需要的话，使用 Element.attachShadow()方法将一个 shadow DOM 附加到自定义元素上。使用通常的 DOM 方法向 shadow DOM 中添加子元素、事件监听器等等。 如果需要的话，使用 和 方法定义一个 HTML 模板。再次使用常规 DOM 方法克隆模板并将其附加到您的 shadow DOM 中。 在页面任何您喜欢的位置使用自定义元素，就像使用常规 HTML 元素那样。 自定义标签即自定义新的 HTML 元素，声明其行为和样式，从自定义的程度分两类： 自定义标签元素（Autonomous custom elements）：完全独立于原始 HTML 元素标签的新标签元素，其所有行为需要开发者定义； 自定义内置元素（Customized built-in）：基于 HTML 原始元素标签的自定义元素，以便于使用原始元素的特性，开发者只需要定义拓展行为； 创建自定义标签元素为了创建一个自定义标签元素，我们需要继承 HTMLELement 类:查看demo123456class GoTop extends HTMLElement &#123; constructor() &#123; super() &#125;&#125;customElements.define('go-top', GoTop) 创建自定义内置元素即在某些基础内置元素的扩展。 Shadow DOM即完全封装 DOM 和 style，将组件完全隔离出来，解决方案就是attachShadow()方法。要创建一个影子 DOM，很简单，使用attachShadow()方法即可，而需要注意的是所有影子 DOM 必须和一个文档中存在的元素（HTML 内置元素或自定义元素）绑定，才能使用： 123var frag = document.createElement('div')var shadowRoot = frag.attachShadow(&#123; mode: 'open' &#125;) // open 指定为开放的封装模式。shadowRoot.innerHTML = '&lt;p&gt;Shadow DOM Content&lt;/p&gt;' HTML template 模板HTML 模板是支持度最高的特性，其允许开发者定义一个直接被复制时才会使用的 html 模板。查看demo123&lt;template id="custom-template&gt; &lt;h1&gt;HTML Templates are rad&lt;/h1&gt;&lt;/template&gt; 在 js 中使用： 12345const template = document.getElementById('custom-template')const templateContent = template.contentconst container = document.getElementById('container')const templateInstance = templateContent.cloneNode(true)container.appendChild(templateInstance) 参考资料： 2018 来谈谈 Web Component]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法(一)]]></title>
    <url>%2F2018%2F08%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%951%2F</url>
    <content type="text"><![CDATA[数据结构与算法（一） 算法是指基于特定的算法模型，旨在解决某一信息处理问题而设计的一个指令序列。 算法应具备几个要素： 输入与输出：对所求问题特定实例的描述称为输入(input),经计算和处理之后得到的信息，即针对输入问题实例的答案，称为输出(output)。在物理上，输出有可能存放于单独的空间，也可能直接存放在原输入所占的存储空间。 基本操作、确定性与可行性：所谓的确定性和可行性是说算法应可描述为由若干条语义明确的基本操作组成的指令序列，且每一基本操作在对应的计算模型中均可实现。 有穷性与正确性： 有穷性(finiteness)是指算法应在执行有限次操作后给出输出。进一步讲，算法不仅会停止，而且输出应符合由问题本身在事先确定的条件，即正确性。 退化与鲁棒性： 指的是算法的健壮程度，即需要处理各种极端的输入实例，这种极端情况就是退化。而鲁棒性就是能充分的应对此类情况。 重用性： 即算法的框架能否便捷的推广到其他场合，多适用性。 算法效率当我们在谈论一个算法时，如何评价这是一个好算法还是一般的算法。 可计算性可计算性是指当编写的代码没有语法错误能顺利编译的情况下，在执行过程中却会出现栈溢出或者无限递归的问题，更甚者，有些应用问题就无法设计出终止的算法。 难解性与计算效率算法对任何输入都能在有穷次操作后输出，然而我们必须要关注的是这其中需要的时间，并需要尽量压缩时间和空间成本。 数据结构无论是算法的输入、输出还是中间计算过程，在计算机中都始终以数据的形式而存在。对于数据的存储、组织、转移等操作，不同的计算模型和平台环境所支持的具体形式不尽相同，其执行效率直接影响算法的效率。这就是数据结构的意义所在。 复杂度度量时间复杂度首先必须明白的是，运行时间由多种因素综合作用而决定。在诸多因素里问题实例的规模往往是决定计算成本的主要因素。一般地，问题规模越大，所需时间越多。随着输入规模的扩大，算法的执行时间将如何增长？执行时间的这一变化趋势可表示为输入规模的一个函数，称作该算法的时间复杂度(time complexity).具体地，特定算法处理规模为n的问题所需的时间记为$T(n)$.从保守估计的角度出发，在规模为n的所有输入中执行时间最长者为$T(n)$,以$T(n)$来度量该算法的时间复杂度。 渐进复杂度至此，比较同一问题的两个算法A和B，通过比较其时间复杂度$T_A(n)$和$T_B(n)$，即可评价二者对于同一规模n的计算效率高低。然而有些算法更适用于小规模的输入，在这种情况下，时间成本就不是一个值得计较的东西，我们可以忽略其处理小规模问题的能力差异，转而关注其在更大规模问题上的表现。 大O记号探讨T(n)的渐进上界，我们需引入”大O记号”。具体的，若存在正常数c和函数f(n),对于任何n &gt;&gt;2 都有$T(n) ≤ c*f(n)$则n足够大之后，f(n)给出T(n)增长速度的一个上界，此时记：$T(n) = O(fn(n))$由此得出大O记号的一下性质： 对于任意常数c&gt;0,有$ O(f(n)) = O(c*f(n))$ 对于任意常数a&gt;b&gt;0,有$O(n^a + n^b) = O(n^a)$ 环境差异、基本操作在实际环境中测出的$T(n)$，无法完全准确的衡量一个算法。不同的硬件平台不同操作系统都会影响时间。我们需要一种客观的超脱于具体硬件平台和系统等因素的标准来衡量。当把时间复杂度理解为算法中各条指令的执行时间之和时，不妨将$T(n)$定义为算法所执行基本操作的总次数。即$T(n)$决定于组成算法的所有语句各自的执行次数以及所含基本操作的数目。 最好最坏平均情况为了对算法复杂度最好的情况做出估计，需要用Ω来标记。如果存在正的常数c和函数g(n),使得对于任何n&gt;&gt;2都有： $T(n) ≥ c*g(n)$n足够大时，g(n)给了T(n)一个渐进下界，则： $T(n) = Ω(g(n))$这里的Ω叫做”大Ω记号”，是算法最好情况下的执行——对于规模为n的输入，算法的运行时间都不低于$Ω(g(n))$。 通过大Ω记号，大O记号可以对算法的时间复杂度做出定量的界定，从渐进的趋势来看，$T(n)$介于$Ω(g(n))$和$O(f(n))$之间，若出现$g(n)=f(n)$的情况，则用Θ来表示。若存在正的常数$C_1 &lt; C_2$,和函数h(n),使得对于任意$n&gt;&gt;2$都有： $C_1●h(n) ≤ T(n) ≤ C_2●h(n) $ n足够大之后，h(n)给出了T(n)一个确界: $T(n) = Θ(h(n))$]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[柯里化]]></title>
    <url>%2F2018%2F07%2F29%2F%E6%9F%AF%E9%87%8C%E5%8C%96%2F</url>
    <content type="text"><![CDATA[柯里化柯里化，可以理解为提前接收部分参数，延迟执行，不立即输出结果，而是返回一个接受剩余参数的函数。因为这样的特性，也被称为部分计算函数。柯里化，是一个&lt;b逐步接收参数的过程。 概念先不管，下面是一道js题目,实现一个add(a)(b)(c)&gt;&gt;&gt;函数:123456789101112131415161718192021222324252627function currying(fn)&#123; var allArgs = []; return function next()&#123; var args = [].slice.call(arguments); if(args.length &gt; 0)&#123; allArgs = allArgs.concat(args); return next; &#125;else&#123; return fn.apply(null, allArgs); &#125; &#125; &#125;var add = currying(function()&#123; var sum = 0; for(var i = 0; i &lt; arguments.length; i++)&#123; sum += arguments[i]; &#125; return sum;&#125;);add(3)(4); // result 7add(3, 4); //7var newAdd = add(5);newAdd(8); //13 add函数将多个值降解为单个值的模式。只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深浅拷贝]]></title>
    <url>%2F2018%2F07%2F18%2FShallow%20copy%20and%20Deep%20copy%2F</url>
    <content type="text"><![CDATA[Shallow copy and Deep copy如何定义深拷贝、浅拷贝两者的分界线是什么？假设我们 B 拷贝了 A，当 A 发生改变时，B 随着改变的话就是浅拷贝，倘若 B 岿然不动则意味着做了深度拷贝。深复制和浅复制最根本的区别在于是否是真正获取了一个对象的复制实体，而不是引用。 12345678let a = 1;let b = a;a = 2;console.log(b); // 1let arr1 = [1, 2];let arr2 = arr1;arr1.pop();console.log(arr2); // [1] 从上面我们可以看出，深浅拷贝只是针对引用数据类型。因为对于内存占用很大的对象而言，在复制时重新开辟内存的代价很大，于是就直接把指针复制了过来(直接引用)。浅拷贝仅仅是在栈内存中保存的引用地址+1。深拷贝就是在堆中重新开辟内存空间。 深拷贝实现Array 的拷贝最简单的当然是 for 循环了。ES6 新增了Array.from和扩展运算符可以达到深拷贝，即不会发生对象的引用。 12345let arr = [1, 2, 3, undefined, function a() &#123;&#125;];let arr2 = Array.from(arr);let arr3 = [...arr];arr.pop();console.log(arr, arr2, arr3); // [ 1, 2, 3, undefined ] [ 1, 2, 3, undefined, [Function: a] ] [ 1, 2, 3, undefined, [Function: a] ] Object 的拷贝对象比较复杂，要考虑嵌套数组，对象，undefined,null等情况。所以我们需要用递归开循环对象，且对数组和对象函数分别判断。 12345678910111213141516171819202122232425262728293031var obj = &#123; arr: [1, 2, 3, &#123; a: '111', b: '2222' &#125;, 45], c: '333333', d: function() &#123;&#125;, e: undefined, f: null&#125;;function deepCopy(o) &#123; if (o instanceof Array) &#123; var n = []; for (var i = 0; i &lt; o.length; ++i) &#123; n[i] = deepCopy(o[i]); &#125; return n; &#125; else if (o instanceof Function) &#123; var n = new Function('return ' + o.toString())(); return n; &#125; else if (o instanceof Object) &#123; var n = &#123;&#125;; for (var i in o) &#123; n[i] = deepCopy(o[i]); &#125; return n; &#125; else &#123; return o; &#125;&#125;var obj2 = deepCopy(obj);console.log(obj2 === obj, obj2); //false &#123; arr: [ 1, 2, 3, &#123; a: '111', b: '2222' &#125;, 45 ],c: '333333',d: [Function],e: undefined,f: null &#125; 当然，deepCopy函数依旧无法将原型链上的属性复制以及未考虑循环引用的问题。当然大多数情况下我们可以用序列化来进行最简单的深拷贝。 12var obj2 = JSON.parse(JSON.stringify(obj));console.log(obj2); // &#123; arr: [ 1, 2, 3, &#123; a: '111', b: '2222' &#125;, 45 ], c: '333333',f: null &#125; 从结果可以看出来，序列化有几个缺点： 无法复制函数 无法复制 undefined 无法解决循环引用 在es2017里，有Object.getOwnPropertyDescriptors和Object.assign进行拷贝。但是： Object.assign()拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。且继承属性和不可枚举属性是不能拷贝的。 12345 let obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;;let obj2 = Object.assign(&#123;&#125;, obj1); obj2.b.c = 3;console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 3&#125;&#125;console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 3&#125;&#125; 一些第三方库的实现 lodash —— .clone() / .cloneDeep() jQuery —— $.clone() / $.extend()]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于es6中的遍历器]]></title>
    <url>%2F2018%2F07%2F17%2F%E5%85%B3%E4%BA%8Ees6%E4%B8%AD%E7%9A%84%E9%81%8D%E5%8E%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[遍历器 一种接口，为各种不同的数据结构提供统一的访问机制。任何数据只要部署了Iterator接口，就可以完成遍历操作。即被认为是可遍历的数据 iterator的作用 为各种数据结构，提供一个统一的、简便的访问接口 使得数据结构的成员能够按某种次序排列 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费 Iterator 的遍历过程 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。 不断调用指针对象的next方法，直到它指向数据结构的结束位置。 可迭代对象规则 主对象/类应该存储一些数据。 主对象/类必须有全局的“众所周知的”symbol，即symbol.iterator作为它的属性，然后按照从规则#3到#6的每条规则来实现一个特有的方法。 symbol.iterator 方法必须返回另一个对象 —— 一个“迭代器(iterator)”对象。 “迭代器(iterator)”对象必须有一个名为 next 的方法。 next方法应该可以访问存储在规则#1的数据。 如果我们调用 iteratorObj.next() ，应该返回存储在规则 #1 中的数据，如果想返回更多的值使用格式{value:&lt;stored data&gt;, done: false}，如果不想返回其他更多的值则使用格式{done: true}。 模拟next()12345678910111213141516let it = makeIterator(['a', 'b']);it.next() // &#123; value: "a", done: false &#125;it.next() // &#123; value: "b", done: false &#125;it.next() // &#123; value: undefined, done: true &#125;function makeIterator(array) &#123; let nextIndex = 0; return &#123; next: function() &#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125;; &#125; &#125;;&#125; 默认的iterator接口 ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内. 123456789101112131415161718192021222324const obj = &#123; [Symbol.iterator] : function () &#123; return &#123; next: function () &#123; return &#123; value: 1, done: true &#125;; &#125; &#125;; &#125;&#125;;var a = obj[Symbol.iterator]();a.next() // &#123;value: 1, done: true&#125;// 数组原生部署了Symbol.iterator属性let arr = ['a', 'b', 'c'];let iter = arr[Symbol.iterator]();iter.next() // &#123; value: 'a', done: false &#125;iter.next() // &#123; value: 'b', done: false &#125;iter.next() // &#123; value: 'c', done: false &#125;iter.next() // &#123; value: undefined, done: true &#125; 与其他遍历语法的比较最原始的for循环123for (var index = 0; index &lt; myArray.length; index++) &#123; console.log(myArray[index]);&#125; 数组内置的forEach123arr.forEach(i =&gt;&#123; console.log(i)&#125;) for...in 为遍历对象而设计 for...of循环相比上面几种做法，有一些显著的优点。 有着同for...in一样的简洁语法，但是没有for...in那些缺点。 不同于forEach方法，它可以与break、continue和return配合使用。 提供了遍历所有数据结构的统一操作接口。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域]]></title>
    <url>%2F2018%2F06%2F26%2F%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[什么是跨域浏览器的同源策略会导致跨域，这里同源策略又分为两种： DOM同源策略：禁止对不同源页面DOM进行操作。这里主要场景是iframe跨域的情况，不同域名的iframe是限制互相访问的。 XmlHttpRequest同源策略：禁止使用XHR对象向不同源的服务器地址发起HTTP请求。 （第二种则是我们常见的协议、域名、端口 同源策略 为什么要有跨域同源策略是为了安全，CSRF攻击正是利用了这一点。 dev模式在开发环境下，我们可以通过关闭谷歌浏览器的同源策略或者用vue-cli自带的proxyTable来跨域。 JSONP我们经常会说，用jsonp可以跨域请求，本质上是利用了script标签的src属性，Web 页面上调用 js 文件不受浏览器同源策略的影响，所以通过 Script 便签可以进行跨域的请求。123456789101112&lt;script type="text/javascript"&gt; function handleResponse(response)&#123; console.log(response); &#125; var oBtn = document.getElementById('btn'); oBtn.onclick = function() &#123; var script = document.createElement("script"); script.src = "https://api.douban.com/v2/book/search?q=javascript&amp;count=1&amp;callback=handleResponse"; document.body.insertBefore(script, document.body.firstChild); &#125;;&lt;/script&gt; 从上面代码我们可以看出为什么jsonp只支持get方式的请求了。 CORSCORS 全称是跨域资源共享（Cross-Origin Resource Sharing），是一种 ajax 跨域请求资源的方式，支持现代浏览器，IE支持10以上。原理是利用服务器没有跨域一说，通过在服务器设置权限从而让浏览器可以访问。大致过程是： 在客户端设置xhr属性withCredentials为true（带cookie） 在服务端需要在response header中设置字段:Access-Control-Allow-Origin: 这里是请求的域名Access-Control-Allow-Credentials:true当我们在A域名下访问B域名的接口时，此时cookie需要手动携带， 在axios中： 123import axios from 'axios'axios.defaults.withCredentials=true;Vue.prototype.$axios = axios; 在jq中： 1xhrFields: &#123;withCredentials: true&#125;, 同样后端的Access-Control-Allow-Origin在这种情况下就不能是*了。因为 ‘*’ 会和 Access-Control-Allow-Credentials:true 冲突，需配置指定的地址。可以通过获取请求头的Origin来自动配置，即谁请求允许谁。相当于通配符换了一种写法。 postMessage这是H5的一个新api,类似于vue父子组件的传值，都是通过一个事件函数发送数据，然后在目标页面监听这个事件。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器缓存]]></title>
    <url>%2F2018%2F06%2F11%2F%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[浏览器的缓存缓存在宏观上分两类： 私有缓存： 用户专享的，各级代理不能缓存的缓存 共享缓存： 能被各级代理缓存的缓存 微观上分三类： 浏览器缓存：通常我们在开发阶段经常说的“清除浏览器缓存” 代理服务器缓存：类似于一个大型的浏览器缓存，只不过被很多人使用 网关缓存：也被称为代理缓存或反向代理缓存，网关也是一个中间服务器，网关缓存一般是网站管理员自己部署，从让网站拥有更好的性能。 CDNS(网络内容分发商)分布网关缓存到整个（或部分）互联网上，并出售缓存服务给需要的网站，比如国内的七牛云、又拍云都有这种服务。 浏览器的缓存策略页面的缓存状态由Response Headers决定。 Age:23146 Cache-Control:public,max-age=2592000&nbsp;&nbsp;(public:指定响应会被缓存，并且在多用户间共享, &nbsp;&nbsp;max-age:设置缓存最大的有效时间) Date:Tue, 28 Nov 2017 12:26:41 GMT ETag:W/“5a1cf09a-63c6” &nbsp;&nbsp;(基于内容生成) Expires:Thu, 28 Dec 2017 05:27:45 GMT Last-Modified:Tue, 28 Nov 2017 05:14:02 GMT &nbsp;&nbsp; ( 服务器端文件的最后修改时间)Vary:Accept-Encoding 1.强缓存阶段(本地缓存:200)Expires是HTTP/1.0中的定义缓存的字段，它规定了缓存过期的一个绝对时间。Cache-Control:max-age=2592000是HTTP/1.1定义的关于缓存的字段，它规定了缓存过期的一个相对时间。优先级上当然是版本高的优先了，max-age &gt; Expires。 这就是强缓存阶段，当浏览器再次试图访问这个CSS文件，发现有这个文件的缓存，那么就判断根据上一次的响应判断是否过期，如果没过期，使用缓存。加载文件，OVER！ 多说一点：关于缓存是从磁盘中获取还是从内存中获取，查找了很多资料，得出了一个较为可信的结论：Chrome会根据本地内存的使用率来决定缓存存放在哪，如果内存使用率很高，放在磁盘里面，内存的使用率很高会暂时放在内存里面。这就可以比较合理的解释了为什么同一个资源有时是from memory cache有时是from disk cache的问题了。 2.弱缓存阶段(协商缓存：304)利用这两个字段浏览器可以进入协商缓存阶段，当浏览器再次试图访问这个CSS文件，发现缓存过期，于是会在本次请求的请求头里携带If-Moified-Since和If-None-Match这两个字段，服务器通过这两个字段来判断资源是否有修改，如果有修改则返回状态码200和新的内容，如果没有修改返回状态码304，浏览器收到200状态码，该咋处理就咋处理(相当于首次访问这个文件了)，发现返回304，于是知道了本地缓存虽然过期但仍然可以用，于是加载本地缓存。然后根据新的返回的响应头来设置缓存。(这一步有所差异，发现不同浏览器的处理是不同的，chrome会为304设置缓存，firefox则不会)😑 具体两个字段携带的内容如下(分别和上面的Last-Modified、ETag携带的值对应)： If-Moified-Since: Tue, 28 Nov 2017 05:14:02 GMT If-None-Match: W/“5a1cf09a-63c6” 最后一张图展示过程：]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的继承]]></title>
    <url>%2F2018%2F06%2F06%2Fjs%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[1. 传统形式 —过多继承了没用的属性原型链可以用来实现共享,这种方式是利用原型让一个引用类型继承另外一个引用类型的属性和方法。并没有隔断new 出来的各个对象 123456789101112131415161718192021Grand.prototype.lastName = 'X';function Grand() &#123; this.name = 'Y';&#125;var grand = new Grand();farther.prototype = grand;function Father() &#123; this.sex = 'man';&#125;var farther = new Father();son.prototype = farther;function Son() &#123; this.age = 12;&#125; 2. 借用构造函数 在子类型构造函数的内部调用超类构造函数，通过使用call()和apply()方法可以在新创建的对象上执行构造函数。 不能继承构造函数的原型 只是部分继承 每构造函数都要多走一次函数 1234567891011121314function Person(name,age,sex) &#123; this.name = name; this.age = age; this.sex = sex;&#125;function Student(name,age,sex,like,time) &#123; Person.call(this,name,age,sex); this.like = like; this.time = time;&#125;var student = new Student(); 3. 共享原型123456789Father.prototype.lastName = 'X';function Father() &#123; this.name = 'Y';&#125;function Son() &#123;&#125;Son.prototype = Father.prototype; 其中，Son.prototype = Father.prototype指向同一个堆，以至于子类新增的属性方法都会反应到父类上。 4. 共享原型+中间层隔离 1234567891011Father.prototype.lastName = 'X';function Father() &#123; this.name = 'Y';&#125;function F()&#123;&#125; // 中间层隔断F.prototype = Father.prototype;Son.prototype = new F();Son.prototype.constructor = Sonfunction Son() &#123;&#125; 或者 1234567891011121314151617function Father()&#123; this.name = "father"; this.colors = ["red","blue","yellow"]; &#125; Father.prototype.sex = "男"; Father.prototype.say = function()&#123; console.log("Oh, My God！")&#125; function Child()&#123; Father.call(this); this.type = "child"; &#125; Child.prototype = Object.create(Father.prototype)； //Object.create 实现类式继承Child.prototype.constructor = Child; // 重定向 constructor 最后，我们写一个函数将继承逻辑抽离出来，F函数即闭包好处之一私有化变量。 12345678910var inherit = (function()&#123; let F = function () &#123;&#125;; return function (Target,Origin) &#123; F.prototype = Origin.prototype; Target.prototype = new F(); Target.prototype.constructor = Target; Target.prototype.uber = Origin.prototype; // 超类 即实际继承自哪儿 &#125;&#125;)() 5. ES6中的继承12345678910class Parent &#123; &#125; class Child extends Parent &#123; constructor(x, y, colors) &#123; //若无，则系统默认添加 super(x, y); // 调用父类的constructor(x, y) this.colors = colors; &#125; toString() &#123; return this.colors + ' ' + super.toString(); // 调用父类的toString() &#125; &#125; super表示父类的构造函数，用来新建父类的this对象。ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面即Parent.apply(this)。ES6 的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六月plan]]></title>
    <url>%2F2018%2F06%2F02%2F%E5%85%AD%E6%9C%88%2F</url>
    <content type="text"><![CDATA[世界上本来就只有那一小部分人才能享受世界上最精彩的人生最近一段时间，一种时不我待的感觉越来越强烈，总觉得时间不够了，来不及做某些事情。 我大概是焦虑了。 关于以后的事情我都没想好，可时间总推着我往前走。在这样一种情况下，我需要做点什么来改变目前的局面。我很难保证我会按照这个计划保质保量的执行下去，也很难确认执行完之后能对我生活产生多大影响。可总归得做点什么才行。 一直以来，我对生活的态度是比较懒散的，随遇而安可能是对我一个很恰当的形容了。在这样一种心理状态下，极致与追求确实是很遥远的事情。 so，是时候改变了。与其说是计划，不如说是未来要养成的习惯。 读书，每天 1 小时+ 的读书时间，在oneNote里新建一个笔记本，写一些读书笔记。六月书单：《博尔赫斯文集》、《人间失格》、《穷查理宝典》、《人类简史》； 早起，早起意味着早睡 23：30睡，六点起床。 锻炼，每天半小时左右的跑步，还有深蹲和十分钟的视频。 英语，英语的学习至关重要，需要好好思考一下。每天 1小时+ 。阅读一些国外博客或者github项目并翻译。 冥想 每晚的23：10分开始到23：30之间。 每天晚上写日记或工作记录，回顾整体所学所做。 学习经济学知识，这是一个大的项目。同样在oneNote建立专门笔记空间。 其实上面每个项目都需要花费大量的精力来坚持下去。而有一些更需要量化的产出才能实现效果。加油。 七月的这个时候会updata一下完成情况。]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[预编译]]></title>
    <url>%2F2018%2F05%2F31%2F%E9%A2%84%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[一段源代码在执行前会经过下面三个步骤： 分词/词法分析（Tokenizing/Lexing） 解析/语法分析（Parsing） 代码生成 JavaScript执行代码会更加复杂，首先js引擎会对代码优化，代码会在执行之前进行编译。下面我们以var a = 1;来描述一下整个过程；首先，编译器会将其拆成词法单元，进而解析成树结构等；具体来说就是：编译过程中，解析器会将 var a = 1 分拆成 var a 和 a = 1 两句来执行; var a编译器会查找当前作用域是否存在 a,如果存在则忽略，否则会在当前作用域声明一个变量 a;接下来由引擎执行 a = 1,同样会首先在当前作用域内超找是否存在一个为 a 的变量，如果有则使用这个变量，也就是说把 1 赋值给它，倘若没有则继续向外层作用域超找，以此类推；若最终未找到，则报错； 函数作用域：首先明白一个概念-&gt; 执行期上下文，这个概念就是指代码的运行环境，也可以理解为作用域。Javascript中代码的运行环境分为以下三种： 全局级别的代码 这个是默认的代码运行环境，一旦代码被载入，引擎最先进入的就是这个环境。 函数级别的代码 当执行一个函数时，运行函数体中的代码。 Eval的代码 在Eval函数内运行的代码。 一个函数，在其执行的前一刻，也就是预编译过程会经过以下四步：1:创建执行期上下文(AO对象====Activation Object)，2:为AO对象添加属性(形参和已经申明的变量)，并且其值为undefind,3:统一实参值和形参，4:找函数申明（不包括表达式赋值var a=function(){}）,并且赋值.]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[碎碎念]]></title>
    <url>%2F2018%2F05%2F30%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%AC%AC%E4%BA%8C%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[爆炸了昨天在本地的文件出了一些问题，然后今天把本地文件删除后从git拉取。各种查资料之后，本地终于跑通，但很无语的是昨天的文章不见了。 教训： 一定要保证 git clone 之后的代码可以无缝衔接。 -&gt; 将一些hexo的依赖项添加到了package.json文件。 本地的develop 分支一定要随时上传到仓库。]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js单线程]]></title>
    <url>%2F2018%2F05%2F30%2Fjs%E5%8D%95%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[事件循环的出现是因为javascript单线程的缘故。 js为什么被设计成单线程呢？我们知道，js作为一门前台脚本语言，是为了用户交互和操作dom等。在这种应用场景下，js必然不能进行多线程的‘自相矛盾’的操作。比如有两个线程，一个要修改dom的内容，一个却要隐藏这个dom。这种操作交互上的冲突制约了js只能是单线程。 单线程的意思是需要排队。每一个事件每一段代码都需要在排队，等待执行。任务有两类，同步和异步。同步任务会老老实实排队，但是异步任务尤其是某些耗时长的任务，主线程会将其抛出到一个名叫‘’任务队列的任务中，这个任务队列会被挂载一边。一旦某一异步有了执行结果，会在任务队列里扔一个‘事件’。当主线程中的同步任务执行完毕了，主线程会搜寻任务队列中的事件进行执行。 以上的一系列过程会被主线程不断重复。所以才有了Event Loop。 如果js的执行仅仅是这样的话，无疑会很简单，但可惜并不是。 当我们学习ES6的promise时，会遇到很多关于先后输出的问题。 Js 中，有两类任务队列：宏任务队列（macro tasks）和微任务队列（micro tasks）。宏任务队列可以有多个，微任务队列只有一个。那么什么任务，会分到哪个队列呢？ 宏任务：script（全局任务）,setTimeout, setInterval, setImmediate, I/O, UI rendering.微任务：process.nextTick, Promise, Object.observer, MutationObserver.我们上面讲到，当stack空的时候，就会从任务队列中，取任务来执行。共分3步： 取一个宏任务来执行。执行完毕后，下一步。取一个微任务来执行，执行完毕后，再取一个微任务来执行。直到微任务队列为空，执行下一步。更新UI渲染。Event Loop 会无限循环执行上面3步，这就是Event Loop的主要控制逻辑。 #事件循环的顺序，决定JS代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。听起来有点绕，我们用文章最开始的一段代码说明：123456789101112setTimeout(function()&#123; console.log('setTimeout');&#125;)newPromise(function(resolve)&#123; console.log('promise');&#125;).then(function()&#123; console.log('then');&#125;)console.log('console'); 这段代码作为宏任务，进入主线程。 先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述) 接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。 遇到console.log()，立即执行。 好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。 ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。 结束。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>
